---
layout:       post
title:        "测试题答案"
author:       "mkk"
header-style: text
catalog:      true
tags:
    - 笔记
---

## day01

> 说明：每题10分，共100分，得到60分及以上算通过

### 1. 如何理解linux中一切皆文件

```
会将各种硬件（CPU/内存）映射成文件
将运行程序进程的内存映射成文件

=> 也就是Linux系统在操作各种硬件、内存时都统一为了文件操作
```

### 2. 列出几个Linux根目录下的文件夹及其作用

```
/bin  可执行命令程序的目录文件
/home  用户的家目录，可以包含n个用户的文件夹，默认就只有我们创建的登陆用户
/etc  系统配置文件目录， 比如：passwd(用户信息)
/usr  用户的安装程序目录， 相当于windows中的Program Files
```

### 3. 现在有一个名为xxx的包，写出安装和卸载的命令

```
sudo apt install xxx
sudo apt remove xxx
```

### 4. 说出Linux中的2个帮助命令并区别它们

```
help: 查看内部命令的帮助文档
man: 查看外部命令（bin下）的帮助文档
```

### 5. 列出4个常用的快捷键及其作用

```
Ctrl + C 或 Q: 停止退出
Ctrl + L 或 clear: 清屏
Tab键： 补全
上下键：查找执行过的命令
```

### 6. 列出查看目录内容和进入目录的命令

```
ls: 列出目录下的内容   =》 ll列出包含隐蔽文件在内的所有文件（夹）详细信息
cd: 进入目录
```

### 7. 列出文件或文件夹的创建、删除、拷贝和移动的命令

```
mkdir: 创建文件夹
touch: 创建文件
rm: 删除文件或文件夹
cp: 拷贝文件或文件夹
mv: 移动文件或文件夹
```

### 8. 列出查看文件内容的2个命令，并区别它们

```
cat: 查看文件的所有内容
tail: 查看文件最后的部分行内容 =》还可以实时监视文件变化
```

### 9. 列出输出重定向和输出过滤的命令

```
>: 输出重定向（覆盖）
>>: 输出重定向（追加）
|grep: 输出过滤
```

### 10. 说说你对文件权限的理解

```
文件权限是为了限制不同用户的操作级别，更安全
权限：读（r）、写(w)、执行(x)
文件：
		可读：查看文件内容  r
		可写：修改文件内容 w
		可执行：可运行  x
		注意：文件是可重命令和删除得看文件夹的权限
目录
		可读：可以ls查看目录下的内容
		可写：可以对目录内文件创建和删除，重命令目录
		可执行：可进入
内部使用3个二进制位来存储权限：rwx
		也就是：4：r, 2: w, 1: x
		可以相加得到多个权限：3：wx  5: rx   6: rw  7: rwx

```

## day02

### 1. 画图说明VIM三种模式之间的转换和命令模式下的命令

![image-20241009192009078](C:\Users\25814\AppData\Roaming\Typora\typora-user-images\image-20241009192009078.png)

### 2. 求两个数及其之间的数的总和

> 这两个数在执行shell时通过参数携带，如果携带的参数小于2个提示“请指定两个数值参数”，指定的两个数如果相等和为其中一个，这两个数可能第一个大，也可能第二个大，计算出结果后输出“总和为？”

![image-20241009192105463](C:\Users\25814\AppData\Roaming\Typora\typora-user-images\image-20241009192105463.png)

## day03

### 1. 区别git与svn

```
SVN: 集中式，开发者本地不能进行版本控制，本地只有仓库的某个版本（一般最新）必须连接上中央仓库才可以
    （必须联网）=》现在使用很少
GIT：分布式，开发者本地有仓库的所有版本，本地就可以进行版本控制（不受网络限制） =》基本都使用
```

### 2. git的三个分区

```
工作区 
暂存区
版本区（本地仓库）
```



### 3. git本地版本控制的基本命令（至少5个）

```
git init	初始化仓库，生成工作区   =》 生成 .git文件夹
git add .		将工作区的更新添加到暂存区
git commit -m "xxx"	将暂存区的更新提交到本地仓库
git status		查看工作区和暂存区的状态（是否有更新）
git reflog		查看历史版本信息
git reset --hard 版本号		得到指定版本的代码
```



### 4. 远程仓库相关的几个基本操作（至少3个）

```
1. 创建远程仓库
2. 将本地仓库的代码推送到远程
3. 克隆远程仓库生成本地仓库
4. 如果本地工作区代码有更新，要提交到本地仓库并推送到远程仓库
5. 如果远程仓库有更新，要拉取到本地仓库
```



### 5. 区别远程仓库的https与ssh两种方式

```
https: 每次推送都需要输入用户名和密码 （通过用户名和密码进行身份校验的）
ssh: 每次推送不需要输入用户名和密码（通过自动携带的私钥与保存在远程的公钥进行匹配校验的）
```



### 6. 说说版本控制冲突产生的原因和解决办法

```
原因： 当2个人将修改推送到同一个分支时，如果修改了同一个文件，后操作的人就会产生冲突
解决：推送失败时先进行拉取，让工具做带冲突的合并， 先利用工具解决冲突代码（一般留下双方），再提交并推送。
```

## day04

### 1. 区别GCC、glibc与GNU C

```
GNU C: C语言标准
glibc: C语言标准的实现
gcc: 将C语言程序处理成可执行二进制程序的编译器
```



### 2. 说说C语言程序从源代码到可执行程序经历的四个处理过程

```
预处理
编译
汇编
链接
```

### 3. 说说使用git管理项目的基本过程

```
	配置忽略：
		指定git对哪些文件夹或文件不进行版本管理
		.gitignore
	创建本地仓库
		git init
		git add .
		git commit -m "初始化项目"
	创建远程仓库
		在gitee上创建仓库
	将本地仓库推送到远程仓库
		git remote add origin url
		git push -u origin 主分支
	本地修改代码先提交到本地仓库再推送到远程仓库
		git add .
		git commit -m "xxx"
		git push origin master
	如果远程仓库有更新，拉取到本地
		git pull origin master
	克隆仓库
		git clone https://gitee.com/zxfjd3g/linux_app
```



### 4. 列出一些文件IO库函数（至少6个）

```
fopen(): 打开一个文件流
fclose()：关闭文件流
fputc()：向文件中写入一个字符
fputs()：向文件中写入一个字符串
fprintf()：向文件中写入指定格式的字符串
fgetc()：读取文件中的一个字符
fgets()：读取文件中的一个字符串
fscanf(): 读取文件中的一个特定格式的字符串，并保存到多个变量

stdin：读取终端的标准输入流
stdout：写到终端的标准输出流
stderr：写到终端的标准错误输出流
输出重定向：可以将stdout和stderr的数据重定向到不同的日志文件中
errno：错误编号， 后面可以根据strerrono得到错误信息
perror()：输出错误信息

```

### 5. 使用IO的系统调用实现文件拷贝的功能，并使用make编译运行

```
编码并截图
```

![image-20241012194342522](C:\Users\25814\AppData\Roaming\Typora\typora-user-images\image-20241012194342522.png)

![image-20241012194409580](C:\Users\25814\AppData\Roaming\Typora\typora-user-images\image-20241012194409580.png)

## day05

### 1.  区别进程和程序

- 程序：程序代码，静态的
- 进程：正在运行的程序，动态的，包括：内存（代码、堆、栈等）和分配给它的其它系统资源（比如：文件描述符）

### 2. 说说进程内存的组成部分

- 文本（程序代码： 程序代码、指令
- 初始化数据：已经初始化的全局变量和静态变量
- 未初始化数据：没有初始化的全局变量和静态变量
- 堆（heap）：malloc动态分配
- 未分配内存：供堆和栈扩展使用的区域
- 栈：局部变量、函数参数、返回地址等
- 参数与环境： 程序参数和环境变量

### 3.  如何验证linux中程序运行内存是虚拟内存而不是物理内存？

- 在父进程中定义一个变量val并赋值
- 通过fork来创建一个子进程, 此时子进程也就有了val变量，且值与父进程是一样的
- 查看父子进程的val的地址，发现地址值一样 =》程序中获取的不是真实内存，而是虚拟内存

### 4. 列出进程相关的的三个函数，并说明其作用

- fork(): 创建当前进程的子进程
- execve(): 在当前进程（一般是子进程）中执行另一个程序（自定义或命令）
- waitpid(): 等待指定pid的子进程执行结束

### 5. 说出进程间通信的三种方式，并简单描述一下其特点

- 管道：利用管道实现两个进程间的单向通信（半双工）
- 共享内存：利用共享内存实现两个进程间通信，不限制单向，但要注意一个写一个读即可
- 消息队列：一个进程向队列发n个数据，另一个进程从队列中顺序接收获取数据

## day06

### 1.  区别进程与线程

- 都是Linux系统可以进行调度执行的执行单元
- 进程是一个运行的程序，有独立私有的内存空间和资源
- 线程是进程内的一个执行单元，一个进程内的所有线程共享进程的空间和资源
- 线程间共享更简单，一个全局变量就搞定，但带来的线程同步问题
- 线程间切换相比进程间切换消耗更小，更适合做高并发处理。

### 2. 列出线程控制的4个方法及其作用

- pthread_create(): 创建线程
- pthread_join()：等待指定线程结束
- pthread_cancel()：取消指定线程
- pthread_exit()：结束当前进程

### 3.  列出线程间同步的几种方式及其特点

- 互斥锁：限制多线程共享资源数据在某个时间段内只能有一个线程操作数据
- 条件变量：控制多个线程间的切换执行
- 信号量：控制多个线程的执行顺序

### 4. 列出消息队列的几个操作

- 创建队列：mq_open()
- 向队列发消息: mq_send()
- 接收获取队列中的消息: mq_receive()
- 删除队列: mq_unlink()

### 5. 列出互斥锁的几个操作

- 初始化锁:  得到内置的初始化锁
- 加锁：在操作共享数据前   lock()
- 解锁：在操作共享数据后 unlock()
- 销毁锁：在最后 destroy()