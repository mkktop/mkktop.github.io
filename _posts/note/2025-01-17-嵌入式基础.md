---
layout:       post
title:        "嵌入式基础"
subtitle:   "核心知识"
date:       2025-01-14 
author:       "mkk"
header-style: text
catalog:      true
tags:
    - 笔记
---

# C语言

## 1.从源码到可执行文件会经历怎样的过程？

- 预编译 :处理预处理指令（#define #include #ifdef #if 等），去掉空格注释，生成干净的源代码  
- 编译: 将源代码翻译成汇编代码，生成汇编文件。  
- 汇编: 将汇编代码翻译成机器码，生成目标文件（二进制文件）。  
- 链接: 将目标文件和程序所依赖的库连接成最终的可执行文件。  

## 2.介绍一下C语言程序的内存模型

![image.png](https://image.kaikun.top/file/1737076842015_image.png)  

## 3.什么是标识符？标识符有什么命名规范？

- 变量、函数、数组、结构体等要素命名时使用的字符序列，称为标识符。  
- 由小写或大写英文字母，0-9 或 _ 组成。  
- 不能以数字开头。 
- 不可以是关键字。  
- 下划线拼接  
- 驼峰命名  

## 4.32位系统，地址用多少个字节表示? 64位系统，地址用多少字节表示？

- 32位系统，地址用4个字节表示。
- 64位系统，地址用8个字节表示。

## 5.C语言变量的声明和定义有什么区别？

- 声明是告诉编译器某个变量的类型和名称，但不指定其值  
- 定义是告诉编译器某个变量的类型和名称，并指定其值  

## 6.变量和常量有什么区别？ 

- 变量的值在程序运行期间可以修改，常量的值不能修改  

## 7.C 语言中有哪些定义常量的方式？有什么区别？

- const: C99新增，定义时需指定数据类型，编译时会类型检查，有作用域，更安全。  
- #define : 预处理阶段文本替换，没有类型检查，没有作用域，更灵活。  

## 8.全局变量和局部变量有什么区别？

- 作用域: 全局变量-整个程序   局部变量-声明该变量的函数或者代码块内
- 生命周期: 全局变量-整个程序运行期间 局部变量-函数或代码块的执行期间  
- 存储位置: 全局变量-全局变量存储在数据区 局部变量-局部变量存储在栈区
- 默认初始值: 全局变量-有默认值，为0  局部变量-没无默认值，随机

## 9.假设有变量num，表达式num ++和++num有什么不同？

- 先取值再运算
- 先运算再取值

## 10.请说几个你经常用到的预处理命令？

- #include #define、#undef、#ifdef、#ifndef #if、#else、#elif、#endif

## 11.如何取消宏定义？

- #undef  

## 12.什么是条件编译，有哪些应用场景？

- 条件编译（Conditional Compilation）是指在程序编译过程中，根据某些条件的不同，决定是否编译某段代码的技术。通常，条件编译通过预处理指令实现，最常见的指令是 #if、#ifdef、#ifndef、#else 和 #endif。  
- 应用场景：跨平台 调试代码 功能开关

## 13.说说你知道的C语言数据类型？

- 整数 char、short、int、long、long long
- 浮点数 float、double、long double  

## 14.整数和浮点数在存储原理上有什么区别？

- 整数: 以二进制补码的形式存储 
- 浮点数:C语言中的浮点数存储遵循IEEE 754标准，采用科学计数法表示。浮点数由三部分组成：符号位：占1位，表示浮点数的正负。
指数部分：占8位（float）或者11位（double），表示数值的规模，采用偏移量表示（通常为127或1023）。
尾数部分：占23位（float）或者52位（double），表示有效数字。

## 15.char类型的本质

- 长度为1个字节（8位）的整数。实际存储的是字符对应的ascii码编码值。

## 16.数据类型的自动转换遵循什么原则？

- 整数类型之间: 窄字节类型转为宽字节类型，有符号类型转为无符号类型   
- 浮点数之间: 精度小的类型转为精度大的类型  
- 整数和浮点数之间: 整数转为浮点数  

## 17.枚举有哪些应用场景？使用枚举类型的好处是什么？   
- 应用场景：状态机中的各个状态可用枚举定义，通用的方法返回值（TRUE，FALSE，SUCCESS、ERROR等）
- 好处：提高代码的可读性  增强类型安全

## 18.typedef 和 #define 定义的类型别名有什么不同？

- typedef：用于创建类型别名，它具有作用域，具有类型安全检查。  
- #define：只是在预处理阶段进行文本替换，不具有作用域，不具有类型安全检查。  

## 19.switch的参数数据类型有什么要求？

- 必须是整型或者枚举类型  

## 20.break和continue有什么区别？

- break：break可以结束掉循环，并可以跳出switch中的case。
- continue：continue以跳出本次循环，循环并未结束继续下一次。  

## 21.C语言数组有什么特点，如何计算数组长度

- 特点：数组中的元素在内存中是依次紧密排列的且有序的。初始化完成长度就是确定的，不能修改。可直接通过索引（下标）获取指定位置的元素，速度很快。
- 长度计算：sizeof(arr) / sizeof(int)  

## 22.C 语言中字符串的本质是什么

- 字符数组，需要特别注意的是所有的字符串都以'\0'（ASCII值为0）结尾 

## 23.现有字符串 char str[]= "hello world"，使用sizeof() 计算的字符串长度和strlen()计算的字符串长度有什么区别  

- sizeof：返回的是字符数组（包括结尾的空字符\0）的长度  
- strlen：返回的是实际的字符个数，不包括结尾的空字符\0 

## 24.什么是多维数组，内存的存储形式是怎样的 

- 数组的元素也是数组就是多维数组。
- 存储形式  
![image.png](https://image.kaikun.top/file/1737079109431_image.png)  

## 25.两个同类型指针相减会得到什么结果

- 同类型的指针相减会得到两个指针之间元素的个数，而不是它们的地址差。

## 26.指针加减整数会得到什么结果

- 指针与整数的加减运算，表示指针所指向的内存地址的移动，指针每次+1（或-1）后移动多少，取决于指针指向的数据类型  

## 27.指针能否比较大小

- 可以，比较的各自指向的内存地址的大小 

## 28.数组名是指针吗，和指针有什么不同？

- 数组名本质：数组实体的标识符，但在有些场景下，会被隐式的转为指向第一个元素的指针，数组本身 sizeof，&取地址，指向第一个元素的指针 其余情况  
- 数组名和指向第一个元素的指针的区别 
![image.png](https://image.kaikun.top/file/1737079266403_image.png)  

## 29.指针数组和数组指针有什么区别？

- 指针数组：是一个数组，其中每个元素都是指针。char *strs[2] = {"hello", "world"};
- 数组指针: 数组指针是一个指针，它指向一个数组。int arr[5] = {1, 2, 3, 4, 5};int (*p_arr)[5] = &arr;

## 30.指针函数和函数指针有什么不同

- 指针函数：是一个函数，其返回值为指针类型 int* fun(intx,int y);
- 函数指针：值一个指针，其指向的是一个函数 int*(*p_fun)(int,int);

## 31.常量指针和指针常量有什么不同？

- 常量指针（pointer to const）：是一个指针，其指向一个常量，其指向的值不可修改const int* ptr;
- 指针常量（const pointer）：只一个常量，其类型是指针，该指针的值本身不可修改 int* const ptr;

## 32.用字符数组和字符指针表示字符串有什么不同？

![image.png](https://image.kaikun.top/file/1737079553247_image.png)  

## 33.什么是空指针

- 空指针是一个不指向任何有效内存地址的指针，在C 语言中用NULL 表示。

## 34.什么是悬空指针

- 悬空指针（Dangling Pointer）是指一个指针变量指向的内存地址已经被释放或者不再有效，但该指针仍然持有该地址的值，悬空指针会导致程序访问无效内存。  

## 35.什么是野指针，如何避免野指针

- 野指针就是指针指向的位置是不可知 
- 未初始化的指针
- 悬空指针
- 越界访问的指针

## 36.指针和引用的区别和用法

- 引用是C++中的概念，C语言中没有。引用相当于是对已有的变量取别名。

## 37.使用结构体变量访问成员和使用结构体指针访问成员有什么不同

- 结构体变量： .  运算符
- 结构体指针： -> 运算符

## 38.结构体的长度如何计算

![image.png](https://image.kaikun.top/file/1737079727805_image.png)  

## 39.结构体和共用体有什么不同

- 两者最大的区别在于内存的使用
- 结构体各成员拥有自己的内存，各自使用且互不干涉，遵循内存对齐原则。
- 联合体所有成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权。一个联合体变量的总长度应至少能容纳最大的成员变量

## 40.形参和实参有什么区别

- 形参：形参是函数定义中声明的参数，用于接收从函数调用中传递的值。形参本质上是局部变量
- 实参：实参是函数调用时传递给函数的具体值或变量。

## 41.C 语言主函数的参数和返回值有什么规则

![image.png](https://image.kaikun.top/file/1737079854496_image.png)  

## 42.什么是函数原型

- 就是函数声明。包括函数名称、返回类型和参数列表，但不包括函数体

## 43.说出几个你常用的 C 语言系统函数

- printf strlen、strcat、strcmp malloc 、free、memcpy、memset abs、sin、cos、tan

## 44.传递指针给函数和传递值给函数有什么区别

- 传递值：实参的值被复制到函数的形参中，函数内部对形参的修改不会影响到实参 用于基本类型参数
- 传递指针：实参的地址被传递给函数，函数可以通过该指针访问和修改实参指向的数据，对指针指向的数据的修改在函数内外都是可见的 用于数组、结构体等较大的数据，以避免复制整个数据块

## 45.什么是回调函数

- 定义：举例说明：调用一个函数A时，将一个自定义的函数B作为参数传入，这个自定义函数B会在某些特定时机被调用，函数B就是一个回调函数。
- 意义：解耦

## 46.带参宏定义和函数有什么区别

![image.png](https://image.kaikun.top/file/1737080058650_image.png)  

## 47.printf()、sprintf()、fprintf() 三个函数有什么不同

- printf() 函数用于将格式化的数据输出到标准输出设备（通常是控制台）。
- sprintf() 函数用于将格式化的数据输出到一个字符串中，而不是标准输出设备。
- fprintf() 函数用于将格式化的数据输出到指定的文件流中。

## 48.static 关键字有什么作用

- 声明静态局部变量：在函数调用结束后不会销毁，生命周期延长至整个程序的执行期间，会存储在内存的全局静态区。
- 声明静态全局变量：它使得变量的作用域仅限于声明它的源文件，不可以被其他源文件访问。
- 声明静态函数：它使得函数的作用域仅限于声明它的源文件，不可以被其他源文件调用。

## 49.extern关键字有什么作用

- extern 关键字在 C 语言中用于声明一个变量或函数在其他文件中定义，它告诉编译器该变量或函数在其他地方已经定义过，不需要再次定义。通常，extern 用于跨文件共享全局变量或函数。

## 50.volatile关键字有什么作用？

- 当你声明一个变量为 volatile 时，编译器会确保CPU每次访问该变量时都直接从内存中读取或写入，而不是使用寄存器缓存的值。以此确保CPU每次都能访问到变量的最新值。

## 51.在1G内存的计算机中能否malloc（1.2G）？为什么？

- 如果操作系统支持虚拟内存，就可以，否则不可以 
![image.png](https://image.kaikun.top/file/1737080218248_image.png)  

## 52.什么是内存泄漏

- 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

## 53.什么是内存溢出

- 定义：内存溢出（Out Of Memory）是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于系统能提供的最大内存。此时程序无法运行，系统提示内存溢出。
- 出现原因：内存泄漏的堆积最终导致内存溢出。需要保存多个耗用内存过大的对象或加载单个超大的对象时，其大小超过了当前剩余的可用内存空间。

## 54.堆和栈有什么区别

- 管理方式：栈内存由编译器自动分配和释放，堆内存需要程序员手动管理
- 效率：栈的访问效率要高于堆。栈的特点是后进先出，因此内存的分配和释放非常简单；而堆是动态分配的，因此多次分配和释放后，会导致空闲内存不连续，这样就会增加内存分配的复杂度。
- 方向：
![image.png](https://image.kaikun.top/file/1737080355507_image.png)  

## 55.堆栈溢出一般是由什么原因导致的？

- 堆溢出：内存泄漏
- 栈溢出：函数调用层级过深/递归层次过深 分配了过大的局部变量

## 56.C语言如何进行动态内存分配，使用哪些函数，有哪些注意事项

- 函数：malloc()，calloc()，realloc()和free()
- 注意事项：避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大。仅在需要时分配内存。只要使用完堆上的内存块，就需要及时释放它，否则可能出现内存泄漏。总是确保释放已分配的内存。在编写分配内存的代码时，就要确定好在代码的什么地方释放内存。

## 57.C语言的库使用过哪些？

- stdio、math、stdlib、string  

