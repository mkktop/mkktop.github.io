---
layout:       post
title:        "ESP32学习记录01"
subtitle:   "核心知识"
date:       2025-05-27 
author:       "mkk"
header-style: text
catalog:      true
tags:
    - 笔记
---

# freeRTOS
esp-idf是基于freeRTOS的框架，所以是首先要掌握的内容  

## freeRTOS任务概述  
在低端设备中，程序基本分为裸机和RTOS，针对简单的程序，我们用裸机程序完全可以满足，一旦功能复杂，程序模块众多，裸机程序往往很难满足我们的需求。因此我们就要用到RTOS系统。  

使用 FreeRTOS 的实时应用程序可以被构建为一组独立的任务。每个任务在自己的上下文中执行，不依赖于系统内的其他任务或 RTOS 调度器本身。  

任务分为四个状态：运行、准备就绪、阻塞、挂起  

### 运行
当任务实际执行时，它被称为处于运行状态。 任务当前正在使用处理器。 如果运行RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。  

### 准备就绪
准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态），但目前没有执行的任务，因为同等或更高优先级的不同任务已经处于运行状态。  

### 阻塞
如果任务当前正在等待时间或外部事件，则该任务被认为处于阻塞状态。例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态），直到延迟结束-一个时间事件。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态任
务通常有一个"超时"期， 超时后任务将被超时，并被解除阻塞，即使该任务所等待的事件没有发生。“阻塞”状态下的任务不使用任何处理时间，不能被选择进入运行状态。

### 挂起
与“阻塞”状态下的任务一样，“挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 vTaskSuspend() 和 xTaskResume()API 调用明确命令时 才会进入或退出挂起状态。  

### 优先级
每个任务均被分配了从 0 到 (configMAX_PRIORITIES-1) 的优先级，其中的configMAX_PRIORITIES 在 FreeRTOSConfig.h 中定义，低优先级数字表示低优先级任务。空闲任务的优先级为零。

### 任务创建

```
BaseType_t xTaskCreatePinnedToCore(
 TaskFunction_t pvTaskCode, //任务函数指针，原型是 voidfun(void *param)
 const char *constpcName, //任务的名称，打印调试可能会有用
const uint32_t usStackDepth,//指定的任务堆栈空间大小（字节）
void *constpvParameters, //任务参数
UBaseType_t uxPriority,
 (configMAX_PRIORITIES- 1)
 // 优 先 级，数字越大，优先级越大，0 到
TaskHandle_t *constpvCreatedTask,
 //传回来的任务句柄
const BaseType_t xCoreID) //分配在哪个内核上运行
```

### 延迟函数

```
// 阻塞指定的时间，单位为系统时钟节拍数
void vTaskDelay( const TickType_t xTicksToDelay )
//用于在指定的时间点之前阻塞任务，直到时间到达。
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement)
```

### 示例
```
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"

void TASK1(void *pvParameters){
    while(1){
        printf("TASK 1\n");
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}
void app_main(void)
{
    xTaskCreatePinnedToCore(TASK1, "TASK1", 2048, NULL, 1, NULL, 0);
    
}
```
## 队列
队列是任务间通信的主要形式。它们可以用于在任务之间以及中断和任务之间发送消息。在大多数情况下，它们作为线程安全的 FIFO（先进先出）缓冲区使用，新数据被发送到队列的后面， 尽管数据也可以发送到前面。  
常用如下API：
```
//创建一个队列，成功返回队列句柄
QueueHandle_t xQueueCreate( 
 UBaseType_t uxQueueLength,//队列容量
 UBaseType_t uxItemSize//每个队列项所占内存的大小（单位是字节）
 );

//向队列头部发送一个消息
BaseType_t xQueueSend(
 QueueHandle_t xQueue,// 队列句柄
 const void * pvItemToQueue, //要发送的消息指针
 TickType_t xTicksToWait  //等待时间);

 //向队列尾部发送一个消息
BaseType_t xQueueSendToBack(
 QueueHandle_t xQueue,// 队列句柄
 const void * pvItemToQueue, //要发送的消息指针
 TickType_t xTicksToWait  //等待时间);

//从队列接收一条消息
BaseType_t xQueueReceive(
 QueueHandle_t xQueue,//队列句柄
 void * pvBuffer,//指向接收消息缓冲区的指针。
 TickType_t xTicksToWait //等待时间);
 
//xQueueSend 的中断版本
BaseType_t xQueueSendFromISR(
 QueueHandle_t xQueue,// 队列句柄
 const void * pvItemToQueue, //要发送的消息指针
 BaseType_t *pxHigherPriorityTaskWoken );////指出是否有高优先级的任务被唤醒
```
### 示例

```
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "freertos/queue.h"

QueueHandle_t xQueue = NULL;
typedef struct{
    int x;
    int y;
}data;
void TASK1(void *pvParameters){//从队列中读取数据
    while(1){
        data data1;
        if (xQueueReceive(xQueue, &data1, portMAX_DELAY))
        {
            ESP_LOGI("TASK1", "Received data: %d %d", data1.x, data1.y);
        }
        
    }
}

void TASK2(void *pvParameters){//向队列中写入数据
    while(1){
        data data1;
        data1.x = 1;
        data1.y = 2;
        if (xQueueSend(xQueue, &data1, portMAX_DELAY))
        {
            ESP_LOGI("TASK2", "Sent data: %d %d", data1.x, data1.y);
            vTaskDelay(1000 / portTICK_PERIOD_MS);
        }
    }
}
void app_main(void)
{
    xQueue = xQueueCreate(10, sizeof(data));
    xTaskCreatePinnedToCore(TASK1, "TASK1", 2048, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(TASK2, "TASK2", 2048, NULL, 1, NULL, 0);

}
```

## 信号量

信号量是用来保护共享资源不会被多个任务并发使用，信号量使用起来比较简单。因为在freeRTOS中它本质上就是队列，只不过信号量只关心队列中的数量而不关心队列中的消息内容，在freeRTOS中有两种常用的信号量，一是计数信号量，而是二进制信号量。  

二进制信号量很简单，就是信号量总数只有1  

```
//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有1个）
SemaphoreHandle_t xSemaphoreCreateBinary( void );

//创建计数信号量，成功则返回信号量句柄
SemaphoreHandle_t xSemaphoreCreateCounting(
UBaseType_t uxMaxCount,//最大信号量数
UBaseType_t uxInitialCount);//初始信号量数

//获取一个信号量，如果获得信号量，则返回 pdTRUE
 xSemaphoreTake( SemaphoreHandle_t xSemaphore,//信号量句柄
 TickType_t xTicksToWait );//等待时间

 //释放一个信号量
xSemaphoreGive( SemaphoreHandle_t xSemaphore ); //信号量句柄

//删除信号量
void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );
```

### 示例

```
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
SemaphoreHandle_t xSemaphore;

void TASK1(void *pvParameters){//释放信号量
    while(1){
        xSemaphoreGive(xSemaphore);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void TASK2(void *pvParameters){//获取信号量
    while(1){
        if(xSemaphoreTake(xSemaphore,portMAX_DELAY)==pdTRUE){
            ESP_LOGI("TASK2","TASK2 is running");
        }
    }
}
void app_main(void)
{
    xSemaphore = xSemaphoreCreateBinary();
    xTaskCreatePinnedToCore(TASK1, "TASK1", 2048, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(TASK2, "TASK2", 2048, NULL, 1, NULL, 0);

}
```